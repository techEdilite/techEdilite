package main

import (
	"errors"
	"fmt"
	"log"
	"os"
	"regexp"
	"time"

	"math/rand"

	"github.com/couchbase/gocb/v2"
	"github.com/go-playground/validator/v10"
	"github.com/gofiber/fiber/v2"
	"github.com/joho/godotenv"
	"golang.org/x/crypto/bcrypt"

	// jwtware "github.com/gofiber/contrib/jwt"
	"github.com/golang-jwt/jwt/v5"
)

type User struct {
	ID       string `json:"id"`
	Name     string `json:"name" validate:"required"`
	Email    string `json:"email" validate:"required,email"`
	Password string `json:"password" validate:"required"`
}

type Address struct {
	ID      string `json:"id"`
	UserID  string `json:"userId"`
	Address string `json:"address" validate:"required"`
}

type Cart struct {
	ID     string   `json:"id" validate:"required"`
	UserID string   `json:"userId" validate:"required"`
	Items  []string `json:"items"`
}

type APIResponse struct {
	Status  int         `json:"status"`
	Message string      `json:"message"`
	Err     string      `json:"err,omitempty"`
	Data    interface{} `json:"data,omitempty"`
}

var cluster *gocb.Cluster
var usersCollection *gocb.Collection
var addressesCollection *gocb.Collection
var cartsCollection *gocb.Collection
var productsCollection *gocb.Collection

var validate *validator.Validate

var productBucket *gocb.Bucket

var bucket *gocb.Bucket

func customCORS(c *fiber.Ctx) error {
	// Allow all origins dynamically
	origin := c.Get("Origin")
	if origin == "" {
		origin = "*"
	}

	c.Set("Access-Control-Allow-Origin", origin)
	c.Set("Access-Control-Allow-Methods", "GET,POST,PUT,DELETE,OPTIONS")
	c.Set("Access-Control-Allow-Headers", "Origin, Content-Type, Accept, Authorization")
	c.Set("Access-Control-Allow-Credentials", "true")

	// Handle preflight OPTIONS request
	if c.Method() == fiber.MethodOptions {
		return c.SendStatus(fiber.StatusNoContent)
	}

	return c.Next()
}

func main() {
	err := godotenv.Load()
	if err != nil {
		log.Fatal("Error loading .env file")
	}

	connectionString := os.Getenv("COUCHBASE_CONNECTION_STRING")
	bucketName := os.Getenv("COUCHBASE_BUCKET_NAME")
	username := os.Getenv("COUCHBASE_USERNAME")
	password := os.Getenv("COUCHBASE_PASSWORD")

	cluster, err = gocb.Connect("couchbase://"+connectionString, gocb.ClusterOptions{
		Authenticator: gocb.PasswordAuthenticator{
			Username: username,
			Password: password,
		},
	})
	if err != nil {
		log.Fatal(err)
	}

	bucket = cluster.Bucket(bucketName)
	productBucket = cluster.Bucket("ProductsBucket")

	err = bucket.WaitUntilReady(10*time.Second, nil)
	if err != nil {
		log.Fatalf("Bucket not ready: %v", err)
	}

	usersCollection = bucket.Scope("users").Collection("users")
	addressesCollection = bucket.Scope("users").Collection("addresses")
	cartsCollection = bucket.Scope("users").Collection("carts")

	productsCollection = productBucket.Scope("products").Collection("products")

	validate = validator.New()

	app := fiber.New()

	app.Use(customCORS)

	app.Post("/register", registerUser)
	app.Post("/login", loginUser)
	// JWT Middleware

	// app.Use("/", AuthMiddleware)

	// app.Use(jwtware.New(jwtware.Config{
	// 	SigningKey: jwtware.SigningKey{Key: []byte("secret")},
	// }))

	app.Get("/users/:userId", getUserProfile)
	app.Put("/users/:userId", updateUserProfile)
	app.Post("/users/:userId/addresses", addUserAddress)
	app.Post("/users/:userId/addresses/:addressId", updateUserAddress)
	app.Post("/users/:userId/cart", addToCart)
	app.Delete("/users/:userId/cart/:itemId", removeFromCart)
	app.Get("/users/:userId/get-cart", getCart)

	app.Listen(":3001")
}

const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"

func generateRandomUserID(length int) string {
	b := make([]byte, length)
	for i := range b {
		b[i] = charset[rand.Intn(len(charset))]
	}
	return string(b)
}

func registerUser(c *fiber.Ctx) error {
	user := new(User)
	if err := c.BodyParser(user); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(APIResponse{Status: fiber.StatusBadRequest, Message: "error", Err: err.Error(), Data: nil})
	}

	if err := validate.Struct(user); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(APIResponse{Status: fiber.StatusBadRequest, Message: "validation error", Err: err.Error(), Data: nil})
	}

	bucket := cluster.Bucket("UsersBucket")

	queryResult, err := bucket.Scope("users").Query(
		"SELECT * FROM `users` WHERE email=$1",
		&gocb.QueryOptions{Adhoc: true, PositionalParameters: []interface{}{user.Email}},
	)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(APIResponse{Status: fiber.StatusInternalServerError, Message: "error", Err: err.Error(), Data: nil})
	}

	var _user UserResponse
	for queryResult.Next() {
		var result UserResponse
		err := queryResult.Row(&result)
		if err != nil {
			return c.Status(fiber.StatusInternalServerError).JSON(APIResponse{Status: fiber.StatusInternalServerError, Message: "error", Err: err.Error(), Data: nil})
		}
		_user = result
	}

	if _user.Users.Email != "" {
		return c.Status(fiber.StatusBadRequest).JSON(APIResponse{Status: fiber.StatusBadRequest, Message: "User already exist", Err: errors.New("User already exist").Error(), Data: nil})

	}

	user.ID = generateRandomUserID(10)

	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(APIResponse{Status: fiber.StatusInternalServerError, Message: "error", Err: err.Error(), Data: nil})
	}

	user.Password = string(hashedPassword)

	_, err = usersCollection.Upsert(user.ID, user, nil)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(APIResponse{Status: fiber.StatusInternalServerError, Message: "error", Err: err.Error(), Data: nil})
	}

	return c.Status(fiber.StatusOK).JSON(APIResponse{Status: fiber.StatusOK, Message: "User registered successfully", Data: user})
}

type UserResponse struct {
	Users User `json:"Users"`
}

type CartResponse struct {
	Cart Cart `json:"carts"`
}

func generateAccessToken(user string) (string, error) {
	claims := jwt.MapClaims{
		"name": user,
		"role": "customer",
		"type": "at",
		"exp":  time.Now().Add(time.Minute * 15).Unix(),
	}

	// Create token
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

	// Generate encoded token and send it as response.
	t, err := token.SignedString([]byte("secret"))
	if err != nil {
		return "", err
	}

	log.Println(t)

	return t, nil
}

func AuthMiddleware(c *fiber.Ctx) error {
	// Get the access token from the cookie
	accessToken := c.Cookies("accessToken")
	if accessToken == "" {
		return c.Status(fiber.StatusUnauthorized).JSON(APIResponse{Status: fiber.StatusUnauthorized, Message: "Unauthorized", Err: "Access token missing"})
	}

	// Parse and validate the access token
	token, err := jwt.Parse(accessToken, func(token *jwt.Token) (interface{}, error) {
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
		}
		return []byte("secret"), nil
	})

	if err != nil {
		// Access token is invalid or expired, check the refresh token
		refreshToken := c.Cookies("refreshToken")
		if refreshToken == "" {
			return c.Status(fiber.StatusUnauthorized).JSON(APIResponse{Status: fiber.StatusUnauthorized, Message: "Login required", Err: "Refresh token missing"})
		}

		// Parse and validate the refresh token
		refreshTokenClaims, err := jwt.Parse(refreshToken, func(token *jwt.Token) (interface{}, error) {
			if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
				return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
			}
			return []byte("secret"), nil
		})

		if err != nil || !refreshTokenClaims.Valid {
			return c.Status(fiber.StatusUnauthorized).JSON(APIResponse{Status: fiber.StatusUnauthorized, Message: "Login required", Err: "Invalid refresh token"})
		}

		userClaims := refreshTokenClaims.Claims.(jwt.MapClaims)

		// Generate a new access token
		newAccessToken, err := generateAccessToken(userClaims["name"].(string))
		if err != nil {
			return c.Status(fiber.StatusInternalServerError).JSON(APIResponse{Status: fiber.StatusInternalServerError, Message: "Internal Server Error", Err: "Failed to generate new access token"})
		}

		// Set the new access token in the cookie
		c.Cookie(&fiber.Cookie{
			Name:     "accessToken",
			Value:    newAccessToken,
			Expires:  time.Now().Add(time.Minute * 15),
			HTTPOnly: true,
			SameSite: "Strict",
		})

		// Parse and validate the new access token
		token, err = jwt.Parse(newAccessToken, func(token *jwt.Token) (interface{}, error) {
			if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
				return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
			}
			return []byte("secret"), nil
		})

		if err != nil {
			return c.Status(fiber.StatusUnauthorized).JSON(APIResponse{Status: fiber.StatusUnauthorized, Message: "Invalid token", Err: "Invalid new access token"})
		}
	}

	if claims, ok := token.Claims.(jwt.MapClaims); ok && token.Valid {
		// Attach user information to the context
		c.Locals("user", claims)
		return c.Next()
	}

	return c.Status(fiber.StatusUnauthorized).JSON(APIResponse{Status: fiber.StatusUnauthorized, Message: "Invalid token", Err: "Invalid access token"})
}

func loginUser(c *fiber.Ctx) error {
	loginRequest := new(User)
	if err := c.BodyParser(loginRequest); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(APIResponse{Status: fiber.StatusBadRequest, Message: "error", Err: err.Error(), Data: nil})
	}

	// if err := validate.Struct(loginRequest); err != nil {
	// return c.Status(fiber.StatusBadRequest).JSON(APIResponse{Status: fiber.StatusBadRequest, Message: "validation error", Err: err.Error(), Data: nil})
	// }

	if loginRequest.Email == "" || loginRequest.Password == "" {
		return c.Status(fiber.StatusBadRequest).JSON(APIResponse{Status: fiber.StatusBadRequest, Message: "validation error", Err: errors.New("mandatory fields missing").Error(), Data: nil})

	}

	bucket := cluster.Bucket("UsersBucket")

	queryResult, err := bucket.Scope("users").Query(
		"SELECT * FROM `users` WHERE email=$1",
		&gocb.QueryOptions{Adhoc: true, PositionalParameters: []interface{}{loginRequest.Email}},
	)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(APIResponse{Status: fiber.StatusInternalServerError, Message: "error", Err: err.Error(), Data: nil})
	}

	var user UserResponse
	for queryResult.Next() {
		var result UserResponse
		err := queryResult.Row(&result)
		if err != nil {
			return c.Status(fiber.StatusInternalServerError).JSON(APIResponse{Status: fiber.StatusInternalServerError, Message: "error", Err: err.Error(), Data: nil})
		}
		user = result
	}

	if user.Users.ID == "" {
		return c.Status(fiber.StatusNotFound).JSON(APIResponse{Status: fiber.StatusNotFound, Message: "User not found", Data: nil})
	}

	err = bcrypt.CompareHashAndPassword([]byte(user.Users.Password), []byte(loginRequest.Password))
	if err != nil {
		return c.Status(fiber.StatusUnauthorized).JSON(APIResponse{Status: fiber.StatusUnauthorized, Message: "Invalid password", Data: nil})
	}

	user.Users.Password = ""

	// Create the Claims
	// claims := jwt.MapClaims{
	// 	"name": user.Users.Name,
	// 	"role": "customer",
	// 	"type": "at",
	// 	"exp":  time.Now().Add(time.Minute * 15).Unix(),
	// }

	// // Create token
	// token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

	// // Generate encoded token and send it as response.
	t, err := generateAccessToken(user.Users.Name)
	if err != nil {
		return c.SendStatus(fiber.StatusInternalServerError)
	}

	// Create the Claims
	claims := jwt.MapClaims{
		"name": user.Users.Name,
		"role": "customer",
		"type": "rt",
		"exp":  time.Now().Add(time.Hour * 168).Unix(), //7 days
	}

	// Create token
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

	// Generate encoded token and send it as response.
	r, err := token.SignedString([]byte("secret"))
	if err != nil {
		return c.SendStatus(fiber.StatusInternalServerError)
	}

	// Set Access Token as HTTP-only, Secure, and SameSite Cookie
	c.Cookie(&fiber.Cookie{
		Name:     "accessToken",
		Value:    t,
		Expires:  time.Now().Add(time.Minute * 15),
		HTTPOnly: true,
		// Secure:   true,
		SameSite: "Strict",
	})

	// Set Refresh Token as HTTP-only, Secure, and SameSite Cookie
	c.Cookie(&fiber.Cookie{
		Name:     "refreshToken",
		Value:    r,
		Expires:  time.Now().Add(time.Hour * 168),
		HTTPOnly: true,
		// Secure:   true,
		SameSite: "Strict",
	})

	c.Cookie(&fiber.Cookie{
		Name:     "userId",
		Value:    user.Users.ID,
		Expires:  time.Now().Add(time.Hour * 168),
		HTTPOnly: true,
		// Secure:   true,
		SameSite: "Strict",
	})

	// return c.JSON(fiber.Map{"token": t})

	return c.Status(fiber.StatusOK).JSON(APIResponse{Status: fiber.StatusOK, Message: "User authenticated successfully", Data: fiber.Map{"accessToken": t, "refreshToken": r, "userData": user}})
}

func getUserProfile(c *fiber.Ctx) error {
	userId := c.Params("userId")

	// log.Println(c.Request().Header.Cookie("userID"))

	// userId := c.Cookies("userID")
	// if userId == "" {
	// 	return c.Status(fiber.StatusUnauthorized).JSON(APIResponse{Status: fiber.StatusUnauthorized, Message: "User not authenticated", Err: "No userID cookie found", Data: nil})
	// }

	getResult, err := usersCollection.Get(userId, nil)
	if err != nil {
		return c.Status(fiber.StatusNotFound).JSON(APIResponse{Status: fiber.StatusNotFound, Message: "User not found", Err: err.Error(), Data: nil})
	}

	var user User
	err = getResult.Content(&user)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(APIResponse{Status: fiber.StatusInternalServerError, Message: "error", Err: err.Error(), Data: nil})
	}

	user.Password = ""

	bucket := cluster.Bucket("UsersBucket")

	queryResult, err := bucket.Scope("users").Query(
		"SELECT * FROM `addresses` WHERE userId=$1",
		&gocb.QueryOptions{Adhoc: true, PositionalParameters: []interface{}{userId}},
	)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(APIResponse{Status: fiber.StatusInternalServerError, Message: "error", Err: err.Error(), Data: nil})
	}

	var userAddress []AddressResponse
	for queryResult.Next() {
		var result AddressResponse
		err := queryResult.Row(&result)
		if err != nil {
			return c.Status(fiber.StatusInternalServerError).JSON(APIResponse{Status: fiber.StatusInternalServerError, Message: "error", Err: err.Error(), Data: nil})
		}
		userAddress = append(userAddress, result)
	}

	cartB := false

	getResult, err = cartsCollection.Get(userId, nil)
	if err != nil {
		re := regexp.MustCompile(`^[^|]+`)
		match := re.FindString(err.Error())

		if match == "document not found " {

		} else {
			return c.Status(fiber.StatusNotFound).JSON(APIResponse{Status: fiber.StatusNotFound, Message: "Cart not found", Err: err.Error(), Data: nil})
		}
	} else {
		cartB = true
	}

	var cart Cart
	var totalPrice = float64(0)

	if cartB {
		err = getResult.Content(&cart)
		if err != nil {

			return c.Status(fiber.StatusInternalServerError).JSON(APIResponse{Status: fiber.StatusInternalServerError, Message: "error", Err: err.Error(), Data: nil})

		}
		//
		// var totalPrice = float64(0)

		for _, items := range cart.Items {
			query := "SELECT * FROM `products`"
			if items != "" {
				query += fmt.Sprintf(" WHERE id = '%s'", items)
			}
			queryResult, err := productBucket.Scope("products").Query(query, &gocb.QueryOptions{Adhoc: true})
			if err != nil {
				return c.Status(fiber.StatusInternalServerError).JSON(APIResponse{Status: fiber.StatusInternalServerError, Message: "Something went wrong!, CODE - 01", Err: err.Error(), Data: nil})
			}
			for queryResult.Next() {
				var productResponse ProductResponse
				err := queryResult.Row(&productResponse)
				if err != nil {
					return c.Status(fiber.StatusInternalServerError).JSON(APIResponse{Status: fiber.StatusInternalServerError, Message: "error", Err: err.Error(), Data: nil})
				}
				log.Println(productResponse.Products.ID)

				totalPrice += productResponse.Products.Price
			}

		}

	}

	return c.Status(fiber.StatusOK).JSON(APIResponse{Status: fiber.StatusOK, Message: "User profile retrieved successfully", Data: fiber.Map{"userInfo": user, "Address": userAddress, "cart": cart, "totalPrice": totalPrice}}) // user})
}

func updateUserProfile(c *fiber.Ctx) error {
	userId := c.Params("userId")
	user := new(User)
	if err := c.BodyParser(user); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(APIResponse{Status: fiber.StatusBadRequest, Message: "error", Err: err.Error(), Data: nil})
	}

	if user.Name == "" && user.Email == "" && user.Password == "" {
		return c.Status(fiber.StatusBadRequest).JSON(APIResponse{Status: fiber.StatusBadRequest, Message: "validation error", Err: errors.New("mandatory fields missing").Error(), Data: nil})

	}

	getResult, err := usersCollection.Get(userId, nil)
	if err != nil {
		return c.Status(fiber.StatusNotFound).JSON(APIResponse{Status: fiber.StatusNotFound, Message: "User not found", Err: err.Error(), Data: nil})
	}

	var newUserDetails User
	err = getResult.Content(&newUserDetails)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(APIResponse{Status: fiber.StatusInternalServerError, Message: "error", Err: err.Error(), Data: nil})
	}

	if user.Name != "" {
		newUserDetails.Name = user.Name
	} else if user.Email != "" {
		newUserDetails.Email = user.Email
	} else if user.Password != "" {

		hashedPassword, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)
		if err != nil {
			return c.Status(fiber.StatusInternalServerError).JSON(APIResponse{Status: fiber.StatusInternalServerError, Message: "error", Err: err.Error(), Data: nil})
		}

		newUserDetails.Password = string(hashedPassword)
	}

	// || user.Email == "" || user.Password == "" {

	// if err := validate.Struct(user); err != nil {
	// 	return c.Status(fiber.StatusBadRequest).JSON(APIResponse{Status: fiber.StatusBadRequest, Message: "validation error", Err: err.Error(), Data: nil})
	// }

	_, err = usersCollection.Upsert(userId, newUserDetails, nil)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(APIResponse{Status: fiber.StatusInternalServerError, Message: "error", Err: err.Error(), Data: nil})
	}

	newUserDetails.Password = ""

	return c.Status(fiber.StatusOK).JSON(APIResponse{Status: fiber.StatusOK, Message: "User profile updated successfully", Data: newUserDetails})
}

func addUserAddress(c *fiber.Ctx) error {
	userId := c.Params("userId")
	if userId == "" {
		return c.Status(fiber.StatusBadRequest).JSON(APIResponse{Status: fiber.StatusBadRequest, Message: "validation error", Err: errors.New("mandatory fields missing").Error(), Data: nil})

	}
	address := new(Address)
	if err := c.BodyParser(address); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(APIResponse{Status: fiber.StatusBadRequest, Message: "error", Err: err.Error(), Data: nil})
	}

	if address.Address == "" {
		return c.Status(fiber.StatusBadRequest).JSON(APIResponse{Status: fiber.StatusBadRequest, Message: "validation error", Err: errors.New("mandatory fields missing").Error(), Data: nil})

	}

	address.ID = generateRandomUserID(10)

	// if err := validate.Struct(address); err != nil {
	// 	return c.Status(fiber.StatusBadRequest).JSON(APIResponse{Status: fiber.StatusBadRequest, Message: "validation error", Err: err.Error(), Data: nil})
	// }

	address.UserID = userId
	_, err := addressesCollection.Upsert(address.ID, address, nil)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(APIResponse{Status: fiber.StatusInternalServerError, Message: "error", Err: err.Error(), Data: nil})
	}

	return c.Status(fiber.StatusCreated).JSON(APIResponse{Status: fiber.StatusCreated, Message: "Address added successfully", Data: address})
}

func updateUserAddress(c *fiber.Ctx) error {
	userId := c.Params("userId")
	addressId := c.Params("addressId")
	address := new(Address)
	if err := c.BodyParser(address); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(APIResponse{Status: fiber.StatusBadRequest, Message: "error", Err: err.Error(), Data: nil})
	}

	if address.Address == "" {
		return c.Status(fiber.StatusBadRequest).JSON(APIResponse{Status: fiber.StatusBadRequest, Message: "validation error", Err: errors.New("mandatory fields missing").Error(), Data: nil})

	}

	_, err := addressesCollection.Get(addressId, nil)
	if err != nil {
		return c.Status(fiber.StatusNotFound).JSON(APIResponse{Status: fiber.StatusNotFound, Message: "Address ID not found", Err: err.Error(), Data: nil})
	}

	address.ID = addressId

	address.UserID = userId

	// if err := validate.Struct(address); err != nil {
	// 	return c.Status(fiber.StatusBadRequest).JSON(APIResponse{Status: fiber.StatusBadRequest, Message: "validation error", Err: err.Error(), Data: nil})
	// }

	address.UserID = userId
	_, err = addressesCollection.Upsert(addressId, address, nil)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(APIResponse{Status: fiber.StatusInternalServerError, Message: "error", Err: err.Error(), Data: nil})
	}

	return c.Status(fiber.StatusOK).JSON(APIResponse{Status: fiber.StatusOK, Message: "Address updated successfully", Data: address})
}

func addToCart(c *fiber.Ctx) error {
	userId := c.Params("userId")
	cart := new(Cart)
	if err := c.BodyParser(cart); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(APIResponse{Status: fiber.StatusBadRequest, Message: "error", Err: err.Error(), Data: nil})
	}

	if len(cart.Items) == 0 {
		return c.Status(fiber.StatusBadRequest).JSON(APIResponse{Status: fiber.StatusBadRequest, Message: "validation error", Err: errors.New("mandatory fields missing").Error(), Data: nil})

	}

	log.Println(userId)
	getCart, err := cartsCollection.Get(userId, nil)
	if err != nil {

		re := regexp.MustCompile(`^[^|]+`)
		match := re.FindString(err.Error())

		if match == "document not found " {
			log.Println("here")
			cart.ID = generateRandomUserID(7)
			_, err := cartsCollection.Upsert(userId, cart, nil)
			if err != nil {
				return c.Status(fiber.StatusInternalServerError).JSON(APIResponse{Status: fiber.StatusInternalServerError, Message: "error", Err: err.Error(), Data: nil})
			}
			return c.Status(fiber.StatusOK).JSON(APIResponse{Status: fiber.StatusOK, Message: "Item added to cart successfully", Data: cart})

		} else {
			return c.Status(fiber.StatusNotFound).JSON(APIResponse{Status: fiber.StatusNotFound, Message: "Something went wrong", Err: err.Error(), Data: nil})

		}
	}

	var _cart Cart
	err = getCart.Content(&_cart)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(APIResponse{Status: fiber.StatusInternalServerError, Message: "error", Err: err.Error(), Data: nil})
	}

	// if _cart.Cart.ID == "" {
	// 	cart.ID = generateRandomUserID(7)
	// 	_, err := cartsCollection.Upsert(userId, cart, nil)
	// 	if err != nil {
	// 		return c.Status(fiber.StatusInternalServerError).JSON(APIResponse{Status: fiber.StatusInternalServerError, Message: "error", Err: err.Error(), Data: nil})
	// 	}

	// } else {

	// log.Println(_cart, getCart)

	// if len(_cart.Items) == 0 {
	// 	return c.Status(fiber.StatusInternalServerError).JSON(APIResponse{Status: fiber.StatusInternalServerError, Message: "temp", Err: "err", Data: nil})

	// }
	for _, items := range cart.Items {
		_, err := productsCollection.Get(items, nil)
		if err == nil {
			_cart.Items = append(_cart.Items, items)

			// return c.Status(fiber.StatusNotFound).JSON(APIResponse{Status: fiber.StatusNotFound, Message: "error", Err: err.Error(), Data: nil})
		}
		// if _cart.Items[i] == items {
		// 	return c.Status(fiber.StatusCreated).JSON(APIResponse{Status: fiber.StatusCreated, Message: "Item added to cart successfully", Data: cart})

		// }
	}

	// for _, items := range cart.Items {

	// }

	_, err = cartsCollection.Upsert(userId, _cart, nil)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(APIResponse{Status: fiber.StatusInternalServerError, Message: "error", Err: err.Error(), Data: nil})
	}

	// query := "SELECT * FROM `carts`"
	// if userId != "" {
	// 	query += fmt.Sprintf(" WHERE userId = '%s'", userId)
	// }

	// queryResult, err := bucket.Scope(os.Getenv("COUCHBASE_SCOPE")).Query(query, &gocb.QueryOptions{Adhoc: true})
	// if err != nil {
	// 	return c.Status(fiber.StatusInternalServerError).JSON(APIResponse{Status: fiber.StatusInternalServerError, Message: "error", Err: err.Error(), Data: nil})
	// }

	// for queryResult.Next() {

	// }

	// if err := validate.Struct(cart); err != nil {
	// 	return c.Status(fiber.StatusBadRequest).JSON(APIResponse{Status: fiber.StatusBadRequest, Message: "validation error", Err: err.Error(), Data: nil})
	// }

	return c.Status(fiber.StatusOK).JSON(APIResponse{Status: fiber.StatusOK, Message: "Item added to cart successfully", Data: cart})
}

func removeFromCart(c *fiber.Ctx) error {
	userId := c.Params("userId")
	itemId := c.Params("itemId")

	getResult, err := cartsCollection.Get(userId, nil)
	if err != nil {
		return c.Status(fiber.StatusNotFound).JSON(APIResponse{Status: fiber.StatusNotFound, Message: "Cart not found", Err: err.Error(), Data: nil})
	}

	var cart Cart
	err = getResult.Content(&cart)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(APIResponse{Status: fiber.StatusInternalServerError, Message: "error", Err: err.Error(), Data: nil})
	}

	for i, item := range cart.Items {
		if item == itemId {
			cart.Items = append(cart.Items[:i], cart.Items[i+1:]...)
			break
		}
	}

	_, err = cartsCollection.Upsert(userId, cart, nil)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(APIResponse{Status: fiber.StatusInternalServerError, Message: "error", Err: err.Error(), Data: nil})
	}

	return c.Status(fiber.StatusOK).JSON(APIResponse{Status: fiber.StatusOK, Message: "Item removed from cart successfully", Data: cart})
}

type Product struct {
	Type        string    `json:"type"`
	ID          string    `json:"id"`
	Name        string    `json:"name"`
	Description string    `json:"description"`
	Price       float64   `json:"price"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
	OneStar     int       `json:"oneStar"`
	TwoStar     int       `json:"twoStar"`
	ThreeStar   int       `json:"threeStar"`
	FourStar    int       `json:"fourStar"`
	FiveStar    int       `json:"fiveStar"`
	Quantity    int       `json:"quantity"`
}

type ProductResponse struct {
	Products Product `json:"products"`
}

type AddressResponse struct {
	Address Address `json:"addresses"`
}

func getCart(c *fiber.Ctx) error {
	userId := c.Params("userId")

	getResult, err := cartsCollection.Get(userId, nil)
	if err != nil {
		return c.Status(fiber.StatusNotFound).JSON(APIResponse{Status: fiber.StatusNotFound, Message: "Cart not found", Err: err.Error(), Data: nil})
	}

	var cart Cart
	err = getResult.Content(&cart)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(APIResponse{Status: fiber.StatusInternalServerError, Message: "error", Err: err.Error(), Data: nil})
	}

	var totalPrice = float64(0)

	for _, items := range cart.Items {
		query := "SELECT * FROM `products`"
		if items != "" {
			query += fmt.Sprintf(" WHERE id = '%s'", items)
		}
		queryResult, err := productBucket.Scope("products").Query(query, &gocb.QueryOptions{Adhoc: true})
		if err != nil {
			return c.Status(fiber.StatusInternalServerError).JSON(APIResponse{Status: fiber.StatusInternalServerError, Message: "Something went wrong!, CODE - 01", Err: err.Error(), Data: nil})
		}
		for queryResult.Next() {
			var productResponse ProductResponse
			err := queryResult.Row(&productResponse)
			if err != nil {
				return c.Status(fiber.StatusInternalServerError).JSON(APIResponse{Status: fiber.StatusInternalServerError, Message: "error", Err: err.Error(), Data: nil})
			}
			log.Println(productResponse.Products.ID)

			totalPrice += productResponse.Products.Price
		}

	}

	return c.Status(fiber.StatusOK).JSON(APIResponse{Status: fiber.StatusOK, Message: "Fetched user cart", Data: fiber.Map{"cart": cart, "totalPrice": totalPrice}}) // cart})
}
